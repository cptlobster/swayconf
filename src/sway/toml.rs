use std::fs::read_to_string;
use std::path::PathBuf;
use toml::{Table, Value};
use crate::sway::config::ConfigFile;
use crate::sway::commands::{Config, Runtime, SubFocus, SubLayout, SubMove};
use crate::sway::options;
use crate::sway::options::RelWorkspace;

fn read(filepath: PathBuf) -> Table {
    read_to_string(filepath).unwrap().parse().unwrap()
}

fn check_command_vecs(commands: Vec<Result<Config, String>>) -> Result<Vec<Config>, String> {
    for cmd in &commands {
        match cmd {
            Err(e) => return Err(e.clone()),
            _ => continue,
        };
    };
    Ok(commands.iter().cloned().map(|c| c.unwrap()).collect())
}

fn parse_to_cfg(table: &Table) -> Result<ConfigFile, String> {
    let sets = match table.get("set") {
        Some(v) => match v.try_into() {
            Ok(t) => check_command_vecs(parse_sets(t)),
            Err(_) => Err("Syntax error: toplevel set parameter must be a table".to_string())
        }
        None => Ok(vec![])
    };
    let execs = match table.get("exec") {
        Some(v) => match v.try_into() {
            Ok(arr) => check_command_vecs(parse_execs(arr)),
            Err(_) => Err("Syntax error: toplevel exec parameter must be an array".to_string())
        }
        None => Ok(vec!())
    };
    let execs_always = match table.get("exec-always") {
        Some(v) => match v.try_into() {
            Ok(arr) => check_command_vecs(parse_execs_always(arr)),
            Err(_) => Err("Syntax error: toplevel exec-always parameter must be an array".to_string())
        }
        None => Ok(vec!())
    };
    let bindsyms = match table.get("bindsym") {
        Some(v) => match v.try_into() {
            Ok(arr) => check_command_vecs(parse_bindsyms(arr)),
            Err(_) => Err("Syntax error: toplevel bindsym parameter must be a table".to_string())
        }
        None => Ok(vec!())
    };
    let bar = match table.get("bar") {
        Some(b) => Some(parse_bar(b)),
        None => None
    };

    let mut commands = Vec::new();
    commands.push(Config::Comment("This config was generated by swayconf".to_string()));
    commands.push(Config::Comment("https://github.com/cptlobster/swayconf".to_string()));
    match sets {
        Ok(v) => {
            let mut vm = v.clone();
            commands.push(Config::Blank);
            commands.push(Config::Comment("global variables".to_string()));
            commands.append(&mut vm);
        }
        Err(e) => return Err(e)
    }
    match execs {
        Ok(v) => {
            let mut vm = v.clone();
            commands.push(Config::Blank);
            commands.push(Config::Comment("startup application exec commands".to_string()));
            commands.append(&mut vm);
        }
        Err(e) => return Err(e)
    }
    match execs_always {
        Ok(v) => {
            let mut vm = v.clone();
            commands.push(Config::Blank);
            commands.push(Config::Comment("startup application exec-always commands".to_string()));
            commands.append(&mut vm);
        }
        Err(e) => return Err(e)
    }
    match bindsyms {
        Ok(v) => {
            let mut vm = v.clone();
            commands.push(Config::Blank);
            commands.push(Config::Comment("bindsyms".to_string()));
            commands.append(&mut vm);
        }
        Err(e) => return Err(e)
    }
    match bar {
        Ok(Some(v)) => {
            commands.push(Config::Blank);
            commands.push(Config::Comment("swaybar configuration".to_string()));
            commands.push(v);
        }
        Ok(None) => {}
        Err(e) => return Err(e)
    }

    Ok(ConfigFile::default(commands))
}

fn parse_bar(value: &Value) -> Result<Config, String> {
    match value.as_table() {
        Some(t) => parse_bar_table(t),
        None => Err("Syntax error: bar must be a table".to_string())
    }
}

fn parse_bar_table(table: Table) -> Result<Config, String> {
    let status_cmd = table.get("status-command").unwrap().as_str().unwrap().to_string();
    let bar_id = table.get("id").unwrap().as_str().unwrap_or("").to_string();
    Ok(Config::Bar{ bar_id, subcommands: format!("status_command {}", status_cmd) })
}

fn parse_sets(table: &Table) -> Vec<Result<Config, String>> {
    table.keys().map(|key| {
        let name = key.to_string();
        match table.get(key) {
            Some(res) => {
                match res.try_into() {
                    Ok(value) => Ok(Config::Set { name, value }),
                    Err(e) => Err(format!("TOML parse error: {}", e)),
                }
            }
            None => {
                Err(format!("Key {} does not exist. This shouldn't be possible.", key))
            }
        }
    }).iter().collect()
}

fn parse_execs(tables: Vec<&Table>) -> Vec<Result<Config, String>> {
    for table in tables {
        match table.get("command") {
            Ok(c) => {
                match c.try_into() {
                    Ok(command) => Config::Exec(command),
                    Err(e) => Err(format!("TOML parse error: {}", e)),
                }
            }
            Err(_) => Err("Syntax error: command parameter missing".to_string()),
        }
    }
}

fn parse_execs_always(tables: Vec<&Table>) -> Vec<Result<Config, String>> {
    for table in tables {
        match table.get("command") {
            Ok(c) => {
                match c.try_into() {
                    Ok(command) => Config::ExecAlways(command),
                    Err(e) => Err(format!("TOML parse error: {}", e)),
                }
            }
            Err(_) => Err("Syntax error: command parameter missing".to_string()),
        }
    }
}

fn parse_bindsyms(table: &Table) -> Vec<Result<Config, String>> {
    table.keys().map(|k| {
        let keys = breakdown_keys(k.clone());
        match table.get(k).unwrap().try_into() {
            Some(res) => {
                let flags = get_bindsym_args(res);
                match match_runtime_command(res) {
                    Ok(c) => {
                        let command = Box::new(c);
                        Ok(Config::Bindsym { flags, keys, command })
                    },
                    Err(e) => Err(format!("Error parsing runtime command: {}", e)),
                }
            }
            None => Err(format!("Syntax error: bindsym {} malformed", k))
        }
    }).collect()
}

fn get_bindsym_args(table: &Table) -> Vec<options::Bindsym> {
    table.keys().filter_map(|k| match k.clone().as_str() {
        "whole-window" => Some(options::Bindsym::WholeWindow),
        "border" => Some(options::Bindsym::Border),
        "exclude-titlebar" => Some(options::Bindsym::ExcludeTitlebar),
        "release" => Some(options::Bindsym::Release),
        "locked" => Some(options::Bindsym::Locked),
        "to-code" => Some(options::Bindsym::ToCode),
        "input-device" => Some(options::Bindsym::InputDevice(String::new())),
        "no-warn" => Some(options::Bindsym::NoWarn),
        "no-repeat" => Some(options::Bindsym::NoRepeat),
        "inhibited" => Some(options::Bindsym::Inhibited),
        _ => None
    }).collect()
}

fn breakdown_keys(keys: String) -> Vec<String> { keys.split("+").collect() }

fn match_runtime_command(table: &Table) -> Result<Runtime, String> {
    let valid_cmds = table.keys().filter_map(|k| {
        match k.clone().as_str() {
            "exit" => Some(Ok(Runtime::Exit)),
            "floating" => Some(parse_floating(table.get("floating").unwrap())),
            "focus" => Some(parse_focus(table.get("focus").unwrap())),
            "layout" => Some(parse_layout(table.get("layout").unwrap())),
            "move" => Some(parse_move(table.get("move").unwrap())),
            "reload" => Some(Ok(Runtime::Reload)),
            "resize" => Some(parse_resize(table.get("resize").unwrap())),
            "split" => Some(parse_split(table.get("split").unwrap())),
            "exec" => Some(parse_exec(table.get("exec").unwrap())),
            "exec-always" => Some(parse_exec_always(table.get("exec-always").unwrap())),
            "kill" => Some(Ok(Runtime::Kill)),
            "workspace" => Some(parse_workspace(table.get("workspace").unwrap())),
            _ => None
        }
    }).collect();
    match valid_cmds.len() {
        0 => Ok(None),
        1 => valid_cmds[0].clone(),
        _ => Err("Syntax error: One and only one runtime command must be declared".to_string()),
    }
}

fn parse_exec(value: &Value) -> Result<Runtime, String> {
    match value.as_table() {
        Some(t) => parse_exec_table(t),
        None => Err("Syntax error: focus parameter must be a table".to_string()),
    }
}

fn parse_exec_table(table: &Table) -> Result<Runtime, String> {
    let nsid = table.get("no-startup-id").unwrap().as_bool().unwrap();
    match table.get("command") {
        Ok(c) => {
            match c.try_into() {
                Ok(command) => {
                    Ok(
                        if nsid { Runtime::Exec(format!("--no-startup-id {}", command)) }
                        else { Runtime::Exec(command) }
                    )
                }
                Err(e) => Err(format!("TOML parse error: {}", e)),
            }
        }
        Err(_) => Err("Syntax error: command parameter missing".to_string()),
    }
}

fn parse_exec_always(value: &Value) -> Result<Runtime, String> {
    match value.as_table() {
        Some(t) => parse_exec_always_table(t),
        None => Err("Syntax error: exec-always parameter must be a table".to_string()),
    }
}

fn parse_exec_always_table(table: &Table) -> Result<Runtime, String> {
    let nsid = table.get("no-startup-id").unwrap().as_bool().unwrap();
    match table.get("command") {
        Ok(c) => {
            match c.try_into() {
                Ok(command) => {
                    Ok(
                        if nsid { Runtime::ExecAlways(format!("--no-startup-id {}", command)) }
                        else { Runtime::ExecAlways(command) }
                    )
                }
                Err(e) => Err(format!("TOML parse error: {}", e)),
            }
        }
        Err(_) => Err("Syntax error: command parameter missing".to_string()),
    }
}

fn parse_floating(value: &Value) -> Result<Runtime, String> {
    let v = match value.as_bool() {
        Some(res) => Some(if res {options::TogglableBool::Enable} else {options::TogglableBool::Disable}),
        None => match value.as_str() {
            Some("toggle") => Some(options::TogglableBool::Toggle),
            Some("true") => Some(options::TogglableBool::Enable),
            Some("enable") => Some(options::TogglableBool::Enable),
            Some("false") => Some(options::TogglableBool::Disable),
            Some("disable") => Some(options::TogglableBool::Disable),
            _ => None
        }
    };
    match v {
        Some(v) => Ok(Runtime::Floating(v)),
        None => Err("Syntax error: floating parameter must be togglable boolean (true, false, or toggle)".to_string()),
    }
}

fn parse_focus(value: &Value) -> Result<Runtime, String> {
    match value.as_table() {
        Some(t) => parse_focus_table(t),
        None => Err("Syntax error: focus parameter must be a table".to_string()),
    }
}

fn parse_focus_table(table: &Table) -> Result<Runtime, String> {
    let valid_cmds = table.keys().filter_map(|k| {
        match k.clone().as_str() {
            "directional" => {
                let dir_str = table.get("directional").unwrap();
                match parse_directional(dir_str) {
                    Ok(direction) => Some(Ok(Runtime::Focus(SubFocus::Directional(direction)))),
                    Err(e) => Some(Err(e)),
                }
            },
            "sibling" => {
                let dir_str = table.get("sibling").unwrap();
                match parse_focus_sibling(dir_str) {
                    Ok(direction) => Some(Ok(Runtime::Focus(SubFocus::Sibling(direction)))),
                    Err(e) => Some(Err(e)),
                }
            }
            "hierarchy" => {
                let dir_str = table.get("hierarchy").unwrap();
                match parse_hierarchy(dir_str) {
                    Ok(direction) => Some(Ok(Runtime::Focus(SubFocus::Hierarchy(direction)))),
                    Err(e) => Some(Err(e)),
                }
            }
            "output" => {
                let dir_table = table.get("directional").unwrap().as_table();
                if dir_table == None {
                    Some(Err("Syntax error: output parameter must be a table".to_string()))
                }
                else {
                    let valid_cmds = dir_table.keys().filter_map(|dk| {
                        match dk.clone().as_str() {
                            "directional" => {
                                let dir_str = dir_table.get("directional").unwrap();
                                match parse_directional(dir_str) {
                                    Ok(direction) => Some(Ok(Runtime::Focus(SubFocus::OutputDirectional(direction)))),
                                    Err(e) => Some(Err(e)),
                                }
                            }
                            "named" => {
                                let name_str = dir_table.get("directional").unwrap();
                                match name_str.as_str() {
                                    Some(ns) => Some(Ok(Runtime::Focus(SubFocus::OutputNamed(ns)))),
                                    None => Some(Err("Syntax error: output name must be a string".to_string()))
                                }
                            }
                            _ => return None
                        }
                    });
                    match valid_cmds.len() {
                        1 => valid_cmds[0].clone(),
                        _ => Err("Syntax error: One and only one move subcommand must be declared".to_string()),
                    }
                }
            },
            _ => None
        }
    }).collect();
    match valid_cmds.len() {
        1 => valid_cmds[0].clone(),
        _ => Err("Syntax error: One and only one move subcommand must be declared".to_string()),
    }
}

fn parse_move(value: &Value) -> Result<Runtime, String> {
    match value.as_table() {
        Some(t) => parse_move_table(t),
        None => Err("Syntax error: move parameter must be a table".to_string()),
    }
}

fn parse_move_table(table: &Table) -> Result<Runtime, String> {
    let valid_cmds = table.keys().filter_map(|k| {
        match k.clone().as_str() {
            "directional" => {
                let dir_str = table.get("directional").unwrap();
                match dir_str.as_table() {
                    Some(t) => {
                        let px = match t.get("px") {
                            Some(val) => match val.as_u8() {
                                Some(v) => Some(v),
                                None => return Err("Syntax error: px parameter must be a number".to_string()),
                            }
                            None => None,
                        };
                        let direction = match parse_directional(t.get("direction").unwrap()) {
                            Ok(direction) => direction,
                            Err(e) => return Err(e),
                        };
                        Some(Ok(Runtime::Move(SubMove::Directional{direction, px})))
                    }
                    None => match parse_directional(dir_str) {
                        Ok(direction) => Some(Ok(Runtime::Move(SubMove::Directional { direction, px: None }))),
                        Err(e) => Some(Err(e)),
                    }
                }
            },
            "coordinates" => {
                let coord_str = table.get("coordinates").unwrap();
                match coord_str.as_table() {

                }
            },
            "center" => {
                let abs_arg = table.get("center").unwrap();
                match abs_arg.as_bool() {
                    Some(absolute) => Some(Ok(Runtime::Move(SubMove::Center{ absolute } ))),
                    None => match abs_arg.as_table() {
                        Some(t) => {
                            let absolute = table.get("absolute").unwrap_or(false).as_bool().unwrap_or(false);
                            Some(Ok(Runtime::Move(SubMove::Center{ absolute })))
                        }
                        None => Some(Err("Syntax error: center parameter must be boolean or table".to_string()))
                    }
                }
            }
            "workspace" => {
                let ws_arg = table.get("workspace").unwrap();
                match ws_arg.as_table() {
                    Some(t) => {
                        match t.get("output") {
                            Some(v) => match parse_focus_sibling(v) {
                                Ok(s) => Some(Ok(Runtime::Move(SubMove::ToWorkspaceOnOutput(s)))),
                                Err(e) => Some(Err(e)),
                            }
                            None => Some(Err("Syntax error: workspace table must have output".to_string()))
                        }
                    },
                    None => match ws_arg.as_str() {
                        Some("prev") => Some(Ok(Runtime::Move(SubMove::ToWorkspace(RelWorkspace::Prev)))),
                        Some("previous") => Some(Ok(Runtime::Move(SubMove::ToWorkspace(RelWorkspace::Prev)))),
                        Some("next") => Some(Ok(Runtime::Move(SubMove::ToWorkspace(RelWorkspace::Next)))),
                        Some("current") => Some(Ok(Runtime::Move(SubMove::ToWorkspace(RelWorkspace::Current)))),
                        Some("back-and-forth") => Some(Ok(Runtime::Move(SubMove::BackAndForth))),
                        Some(_) => Some(Err("Syntax error: workspace string parameter must be one of: (prev, next, current, back-and-forth)".to_string())),
                        None => Some(Err("Syntax error: workspace parameter must be a table or string".to_string()))
                    }
                }
            }
            "output" => {
                let output_arg = table.get("output").unwrap();
                match output_arg.as_table() {
                    Some(t) => {
                        match t.get("directional") {
                            Some(v) => match parse_directional(v) {
                                Ok(s) => Some(Ok(Runtime::Move(SubMove::ToDirectionalOutput(s)))),
                                Err(e) => Some(Err(e)),
                            }
                            None => Some(Err("Syntax error: output table must have name".to_string()))
                        }
                    },
                    None => match output_arg.as_str() {
                        Some(s) => Some(Ok(Runtime::Move(SubMove::ToNamedOutput(s)))),
                        None => Some(Err("Syntax error: output parameter must be a table or string".to_string()))
                    }
                }
            }
            _ => None
        }
    }).collect();
    match valid_cmds.len() {
        1 => valid_cmds[0].clone(),
        _ => Err("Syntax error: One and only one move subcommand must be declared".to_string()),
    }
}


fn parse_resize(value: &Value) -> Result<Runtime, String> {
    match value.as_table() {
        Some(t) => parse_resize_table(t),
        None => Err("Syntax error: resize parameter must be a table".to_string()),
    }
}
fn parse_resize_table(table: &Table) -> Result<Runtime, String> {
    let change_str = table.get("change").unwrap().as_str().unwrap();
    let change = match change_str {
        "grow" => options::Size::Grow,
        "shrink" => options::Size::Shrink,
        _ => return Err("Syntax error: resize parameter must be a table".to_string()),
    };
    let x: Option<u8> = match table.get("width") {
        Some(xv) => match xv.try_into() {
            Some(xvv) => Some(xvv),
            None => return Err("Syntax error: width parameter must be an integer".to_string()),
        },
        None => None
    };
    let y: Option<u8> = match table.get("height") {
        Some(yv) => match yv.try_into() {
            Some(yvv) => Some(yvv),
            None => return Err("Syntax error: height parameter must be an integer".to_string()),
        },
        None => None
    };
    let px = match table.get("px") {
        Some(v) => match v.try_into() {
            Some(vv) => vv,
            None => return Err("Syntax error: px parameter must be boolean".to_string()),
        }
        None => false
    };
    let pt = match table.get("ppt") {
        Some(v) => match v.try_into() {
            Some(vv) => vv,
            None => return Err("Syntax error: pt parameter must be boolean".to_string()),
        }
        None => !px
    };
    if px == pt { return Err("Syntax error: px and pt must not be equal".to_string()); }
    let unit = if px { options::Units::Px } else { options::Units::Ppt };
    match (x, y) {
        (Some(_), Some(_)) => Err("Syntax error: x and y must not be equal".to_string()),
        (None, None) => Err("Syntax error: x and y must not be equal".to_string()),
        (x, y) => Ok(Runtime::Resize{change, x, y, unit}),
    }
}

fn parse_workspace(value: &Value) -> Result<Runtime, String> {
    match value.as_u8() {
        Some(number) => Ok(Runtime::Workspace { number, name: None }),
        None => {
            match value.as_table() {
                Some(t) => {
                    let number = t.get("number").unwrap().as_u8();
                    let name = t.get("name").unwrap().as_str();
                    Ok(Runtime::Workspace{ number, name })
                }
                None => Err("Syntax error: Workspace must be integer or table"),
            }
        }
    }
}

fn parse_split(value: &Value) -> Result<Runtime, String> {
    match value.as_str() {
        Some("horizontal") => Ok(Runtime::Split(options::Split::Horizontal)),
        Some("vertical") => Ok(Runtime::Split(options::Split::Vertical)),
        Some("none") => Ok(Runtime::Split(options::Split::None)),
        Some(_) => Err("Syntax error: Split must be one of (horizontal, vertical, none)".to_string()),
        None => Err("Syntax error: must be a string".to_string()),
    }
}

fn parse_directional(value: &Value) -> Result<options::Directional, String> {
    match value.as_str() {
        Some("up") => Ok(options::Directional::Up),
        Some("down") => Ok(options::Directional::Down),
        Some("left") => Ok(options::Directional::Left),
        Some("right") => Ok(options::Directional::Right),
        Some(_) => Err("Syntax error: must be one of (up, down, left, right)".to_string()),
        None => Err("Syntax error: must be a string".to_string()),
    }
}

fn parse_focus_sibling(value: &Value) -> Result<options::FocusSibling, String> {
    match value.as_str() {
        Some("next") => Ok(options::FocusSibling::Next),
        Some("prev") => Ok(options::FocusSibling::Prev),
        Some(_) => Err("Syntax error: must be one of (next, prev)".to_string()),
        None => Err("Syntax error: must be a string".to_string()),
    }
}

fn parse_hierarchy(value: &Value) -> Result<options::Hierarchy, String> {
    match value.as_str() {
        Some("parent") => Ok(options::Hierarchy::Parent),
        Some("child") => Ok(options::Hierarchy::Child),
        Some(_) => Err("Syntax error: must be one of (parent, child)".to_string()),
        None => Err("Syntax error: must be a string".to_string()),
    }
}

fn parse_layout(value: &Value) -> Result<Runtime, String> {
    match value.as_table() {
        Some(t) => parse_layout_table(t),
        None => Err("Syntax error: layout parameter must be a table".to_string()),
    }
}

fn parse_layout_table(table: &Table) -> Result<Runtime, String> {
    let valid_cmds = table.keys().filter_map(|k| {
        match k.clone().as_str() {
            "set" => Some(parse_layout_set(table.get("set").unwrap())),
            "cycle" => Some(parse_layout_cycle(table.get("layout").unwrap())),
            _ => None
        }
    }).collect();
    match valid_cmds.len() {
        1 => valid_cmds[0].clone(),
        _ => Err("Syntax error: One and only one layout subcommand must be declared".to_string()),
    }
}

fn parse_layout_set(value: &Value) -> Result<Runtime, String> {
    let layout = match value.as_str() {
        Some("default") => Ok(options::Layout::Default),
        Some("stacking") => Ok(options::Layout::Stacking),
        Some("tabbed") => Ok(options::Layout::Tabbed),
        Some("splith") => Ok(options::Layout::SplitH),
        Some("split-h") => Ok(options::Layout::SplitH),
        Some("splitv") => Ok(options::Layout::SplitV),
        Some("split-v") => Ok(options::Layout::SplitV),
        Some(_) => Err("Syntax error: must be one of (default, stacking, tabbed, splith, splitv)".to_string()),
        None => Err("Syntax error: must be a string".to_string()),
    };
    match layout {
        Ok(l) => Ok(Runtime::Layout(SubLayout::Set(l))),
        Err(e) => Err(e)
    }
}
fn parse_layout_cycle(value: &Value) -> Result<Runtime, String> {
    fn parse_cycle_single_arg(arg: String) -> Option<options::LayoutCycleSingle> {
        match arg.as_str() {
            "split" => Some(options::LayoutCycleSingle::Split),
            "all" => Some(options::LayoutCycleSingle::All),
            _ => None
        }
    }
    fn parse_cycle_multi_arg(arg: String) -> Option<options::LayoutCycleMulti> {
        match arg.as_str() {
            "stacking" => Some(options::LayoutCycleMulti::Stacking),
            "tabbed" => Some(options::LayoutCycleMulti::Tabbed),
            "splith" => Some(options::LayoutCycleMulti::SplitH),
            "split-h" => Some(options::LayoutCycleMulti::SplitH),
            "splitv" => Some(options::LayoutCycleMulti::SplitV),
            "split-v" => Some(options::LayoutCycleMulti::SplitV),
            _ => None
        }
    }
    match value.as_str() {
        Some(a) => match parse_cycle_single_arg(a.to_string()) {
            Some(s) => Ok(Runtime::Layout(SubLayout::Cycle(s))),
            None => Err("Syntax error: must be one of (all, split)".to_string()),
        }
        None => match value.as_array() {
            Some(arr) => {
                let args = arr.iter().filter_map(parse_cycle_multi_arg).collect::<Vec<options::LayoutCycleMulti>>();
                if args.len() == 0 { Err("Syntax error: must have at least one valid argument".to_string()) }
                else { Ok(Runtime::Layout(SubLayout::Cycle(args))) }
            }
            None => Err("Syntax error: must be a string or array".to_string()),
        }
    }
}

fn parse_layout_opt(value: &Value) -> Result<options::Layout, String> {
    match value.as_str() {
        Some("tabbed") => Ok(options::Layout::Tabbed),
        Some("default") => Ok(options::Layout::Default),
        Some("split-h") => Ok(options::Layout::SplitH),
        Some("split-v") => Ok(options::Layout::SplitV),
        Some("stacking") => Ok(options::Layout::Stacking),
        Some(_) => Err("Syntax error: must be one of (default, stacking, tabbed, split-h, split-v)".to_string()),
        None => Err("Syntax error: must be a string".to_string()),
    }
}